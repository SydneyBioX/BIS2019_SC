<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Sydney Precision Bioinformatics Group" />

<meta name="date" content="2019-11-04" />

<title>Downstream analysis</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">SingleCellPlus - CPC</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="qc.html">QC Process</a>
</li>
<li>
  <a href="scMerge.html">scMerge</a>
</li>
<li>
  <a href="downstream.html">Downstream Analysis</a>
</li>
<li>
  <a href="acknowledgement.html">Acknowledgement</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Downstream analysis</h1>
<h4 class="author">Sydney Precision Bioinformatics Group</h4>
<h4 class="date">04 November 2019</h4>

</div>


<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>We have now preprocessed and merged our single cell data. The next step is to analyse the data for cell type identification, identification of marker genes and <em>et cetera</em>. We will focus on some simple steps of downstream analysis for single cell RNA-sequencing (scRNA-seq) data as shown below.</p>
<ol style="list-style-type: decimal">
<li>What are the cell types present in the dataset?</li>
<li>What are these cell clusters?</li>
<li>For a gene of interest, how can I visualise the gene expression distribution?</li>
<li>What are the cell type composition in the data?</li>
</ol>
<p>We will be using some of the functions we developed in our <code>scdney</code> package. You may visit our package website for the vignette and further details about <a href="https://sydneybiox.github.io/scdney/"><code>scdney</code></a>.</p>
<div id="loading-packages" class="section level2">
<h2><span class="header-section-number">1.1</span> Loading packages</h2>
<pre class="r"><code>suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(SummarizedExperiment)
  library(dplyr)
  library(edgeR)
  library(scdney)
  library(mclust)
  library(Rtsne)
  library(parallel)
  library(cluster)
  library(ggplot2)
  library(MAST)
  library(viridis)
  library(ggpubr)
  library(plyr)
  library(monocle)
  library(scClassify)
})

theme_set(theme_classic(16))
#</code></pre>
</div>
<div id="loading-data" class="section level2">
<h2><span class="header-section-number">1.2</span> Loading data</h2>
<p>In the scMerge publication, we have merged <a href="https://sydneybiox.github.io/scMerge/articles/case_study/Mouse_Liver_Data.html">four mouse liver datasets</a> together. This data is a bit too large for us to work with in this workshop, hence, we will take the merged data with all four datasets and subset ourselves to only the Su and Yang datasets. Some processings were performed in this data compared to the previous section, namely, the Megakaryocyte, Erythrocyte cells from the previous section are labelled as Hematopoietic cells in this section.</p>
<pre class="r"><code>datapath = &quot;./data/&quot;
# datapath = &quot;/home/data/&quot;
sce_scMerge = readRDS(paste0(datapath, &quot;liver_scMerge.rds&quot;))

## We will subset Su et al. and Yang et al. datasets.
ids = colData(sce_scMerge)$batch %in% c(&quot;GSE87795&quot;, &quot;GSE90047&quot;)

subset_data = sce_scMerge[,ids]

## We do not need the full data any more
rm(sce_scMerge)

lab = colData(subset_data)$cellTypes

nCs = length(table(lab))

mat = SummarizedExperiment::assay(subset_data, &quot;scMerge&quot;)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-2-1.png" width="1152" /></p>
</div>
</div>
<div id="q1" class="section level1">
<h1><span class="header-section-number">2</span> What are the cell types present in the dataset?</h1>
<p>Typically, a single cell RNA-sequencing experiment does not come with labelled cell type information for individual cells. We will need to identify cell types of indivdual cells in our data with bioinformatics analysis.</p>
<p>Before we identify the cell types in the dataset, we need to first identify how many distinct groups of populations we can find from our data. One common method to achieve this is a statistical technique called <strong>clustering</strong>. A clustering method will group similar samples (cells) together and partition samples that are different by comparing their feature information (gene expression).</p>
<p>There are two components that ultimately determine the performance of a clustering method:</p>
<ul>
<li>The <strong>similarity metric</strong> that determines if two cells are similar to each other, and</li>
<li>The <strong>algorithm</strong> itself that uses the similarity metric to perform the grouping operations.</li>
</ul>
<p>In our recent study, we found Pearson correlation to be the optimal similarity metric for comparing single cell RNA-seq data ( <a href="https://academic.oup.com/bib/advance-article-abstract/doi/10.1093/bib/bby076/5077112?redirectedFrom=fulltext"><em>Kim et al., 2018</em></a> ). Therefore in this workshop, we will utilise <code>scClust</code> in our <code>scdney</code> package, which implemented 2017 Nature methods clustering algorithm <code>SIMLR</code> with pearson correlation.</p>
<div id="how-many-distinct-groups-of-populations-are-there-in-my-dataset" class="section level2">
<h2><span class="header-section-number">2.1</span> How many distinct groups of populations are there in my dataset?</h2>
<p>Typical clustering methods (except for some methods like hierarchical clustering) require users to specify the number of distinct groups (<code>k</code>) to cluster from your data. In the context of this data, we can think of <code>k</code> as the the number of cell types.</p>
<p>In an unsupervised setting, we do not know the exact number and therefore, in a practical setting, we should run clustering for various numbers for <code>k</code> and evaluate their clustering performance.</p>
<p><strong>However</strong>, due to the time limit of this workshop, we will only run the <code>scClust</code> clustering for <code>k = 6</code> as a demonstration and load a saved result with more values of <code>k</code> computed.</p>
<pre class="r"><code>## For demonstration purpose, we will run k = 6 (which is actually the number of cell types in our dataset)
simlr_result_k6 = scClust(mat, 6, similarity = &quot;pearson&quot;, method = &quot;simlr&quot;, seed = 1, cores.ratio = 0, geneFilter = 0)

load(&quot;data/simlr.results.RData&quot;)</code></pre>
<p>[Extension] If you are interested, this is how you can compute <code>data/simlr.results.RData</code> by yourself.</p>
<pre class="r"><code>## We will NOT run for various `k` to save time. Instead, we will load pre-computed results for `k` between 3 to 8

## This is an easy way to run `scClust` for k = 3, 4, 5, 6, 7, 8.
all_k = 3:8
simlr_results = sapply(as.character(all_k), function(k) {
  scClust(mat, as.numeric(k), similarity = &quot;pearson&quot;, method = &quot;simlr&quot;, seed = 1, cores.ratio = 0, geneFilter = 0)
}, USE.NAMES = TRUE, simplify = FALSE)</code></pre>
</div>
<div id="how-do-we-select-optimal-k" class="section level2">
<h2><span class="header-section-number">2.2</span> How do we select optimal <code>k</code>?</h2>
<p>If our <code>k</code> is optimal, we should expect that each cluster is tightly packed together and the distances within the clusters, within-cluster sum of squares (WSS) are expected to be small. Thus, we will select the <code>k</code> with a small total WSS (compact clusters). This is called the “elbow” method.</p>
<pre class="r"><code># Find total WSS from all cluster outputs
all_wss = sapply(simlr_results, function(result) {
  sum(result$y$withinss)
}, USE.NAMES = TRUE, simplify = TRUE)

plot_data = data.frame(
  k = as.integer(names(all_wss)),
  total_wss = all_wss
)

ggplot(plot_data,
       aes(x = k,
           y = total_wss)) +
  geom_point(size = 3) +
  stat_smooth(method = loess, col = &quot;red&quot;,
              method.args = list(degree = 1), se = FALSE) +
  labs(title = &quot;Compare Total WSS for each k&quot;,
       y = &quot;Total WSS&quot;)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-6-1.png" width="768" /></p>
<p>As shown in this plot, the graph begins to plateau from <code>k</code> = 5. We can estimate that k is around 5 or 6. We can further investigate using silhouette scores or other metrics but using our t-SNE plot (this may require a bit of practical experience) we will estimate <code>k</code> = 6.</p>
<h4>
<span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz
</h4>
<ol style="list-style-type: decimal">
<li>We can determine <code>k</code> with compactness of the clusters. What other measures can we use to determine <code>k</code>?</li>
<li>How would you determine the optimal number of clusters for hierarchical clustering?</li>
</ol>
<!-- <i class="fi-lightbulb"></i> -->
<h4>
<span class="fi-lightbulb" aria-hidden="true"></span>
</h4>
</div>
<div id="effect-of-similarity-metrics" class="section level2">
<h2><span class="header-section-number">2.3</span> Effect of similarity metrics</h2>
<p>For the purpose of demonstration, we would like to highlight the effect of similarity metric to your cluster output. We will first compute a t-SNE plot and then overlay that with</p>
<ul>
<li>Clustering result using Pearson correlation</li>
<li>Clustering result using Euclidean distance</li>
<li>True cell type labels from the publications</li>
</ul>
<pre class="r"><code>## To run scClust with euclidean distance, uncommnet the following lines.
## simlr_result_eucl_k6 = scClust(mat, 6, similarity = &quot;euclidean&quot;, method = &quot;simlr&quot;, seed = 1, cores.ratio = 0, geneFilter = 0)

## for convenience, we will load our pre-computed result
load(paste0(datapath, &quot;simlr_result_eucl_k6.RData&quot;))</code></pre>
<pre class="r"><code># create tsne object
set.seed(123)
tsne_result = Rtsne(t(mat), check_duplicates = FALSE)
#################################################
tmp_lab = as.numeric(factor(lab))
pear_cluster = plyr::mapvalues(
  simlr_result_k6$y$cluster,
  from = c(1,2,3,4,5,6),
  to = c(2,3,1,4,6,5)
)
eucl_cluster = plyr::mapvalues(
  simlr_result_eucl_k6$y$cluster,
  from = c(1,2,3,4,5,6),
  to = c(6,2,4,3,1,5)
)
#################################################

plot_data = data.frame(
  tsne1 = rep(tsne_result$Y[,1], 3),
  tsne2 = rep(tsne_result$Y[,2], 3),
  cluster = factor(c(tmp_lab, pear_cluster, eucl_cluster)),
  label = rep(c(&quot;Truth&quot;, &quot;Pearson&quot;, &quot;Euclidean&quot;), each = length(lab)))


ggplot(plot_data, aes(x = tsne1, y = tsne2, colour = cluster)) +
  geom_point(size = 2) +
  labs(title = &quot;t-SNE plot&quot;) +
  facet_grid(~label) +
  theme(legend.position = &quot;none&quot;)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-8-1.png" width="960" /></p>
<pre class="r"><code>plot_data2 = data.frame(
  Truth = lab,
  computed_cluster = as.factor(c(pear_cluster, eucl_cluster)),
  label = rep(c(&quot;Pearson&quot;, &quot;Euclidean&quot;), each = length(lab))
)


plot_data2 %&gt;%
  dplyr::group_by(Truth, computed_cluster, label) %&gt;%
  dplyr::summarise(n = n()) %&gt;%
  dplyr::ungroup() %&gt;%
  tidyr::complete(Truth, computed_cluster, label, fill = list(n = 0)) %&gt;%
  ggplot(aes(x = computed_cluster,
             y = Truth,
             fill = n, label = n)) +
  geom_tile() +
  geom_text() +
  facet_wrap(~label) +
  scale_fill_distiller(palette = &quot;Blues&quot;, direction = 1) +
  labs(title = &quot;&quot;)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-9-1.png" width="960" /></p>
<h4>
<span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz
</h4>
<ol style="list-style-type: decimal">
<li>From your observation of the above t-SNE plot, did our clustering method (with Pearson correlation) group cells well?</li>
</ol>
<p><strong>[Optional]</strong> We can evaluate the clustering performance using the cell type labels provided from the publications.</p>
<pre class="r"><code># ARI
ari = c(mclust::adjustedRandIndex(lab, simlr_result_eucl_k6$y$cluster),
        mclust::adjustedRandIndex(lab, simlr_result_k6$y$cluster))

# NMI
nmi = c(igraph::compare(as.numeric(factor(lab)),
                        simlr_result_eucl_k6$y$cluster, method = &quot;nmi&quot;),
        igraph::compare(as.numeric(factor(lab)),
                        simlr_result_k6$y$cluster, method = &quot;nmi&quot;))

plot_data = data.frame(
  dist = rep(c(&quot;Euclidean&quot;, &quot;Pearson&quot;), 2),
  value = c(ari, nmi),
  eval = rep(c(&quot;ARI&quot;, &quot;NMI&quot;), each = 2)
)

ggplot(plot_data, aes(x = dist, y = value, fill = dist)) +
  geom_bar(stat=&quot;identity&quot;) +
  facet_grid(col = vars(eval)) +
  labs(x = &quot;Similarity metrics&quot;,
       y = &quot;Evalution score&quot;,
       title = &quot;Effect of similarity metrics in scRNA-seq data&quot;) +
  theme(legend.position = &quot;none&quot;)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-10-1.png" width="960" /></p>
</div>
</div>
<div id="q2" class="section level1">
<h1><span class="header-section-number">3</span> What are these cell clusters?</h1>
<p>Now that we have clustered all the cells to 6 distinct groups, we may want to find out what these clusters are, i.e. what cell types are there in my dataset? Thus, we may ask what defines a cell type?</p>
<p>We can use <strong>marker genes</strong> to identify cell types.</p>
</div>
<div id="what-are-the-marker-genes-that-distinguish-the-different-cell-types" class="section level1">
<h1><span class="header-section-number">4</span> What are the marker genes that distinguish the different cell types?</h1>
<p>Here we provide a function that allows one to find differentially expressed genes between a cluster and the remaining clusters. The input of this function is the expression matrix and the cluster ID. The output is a list of marker genes and their associated p-values.</p>
<p>Here we provide an example of this using the <code>findmarker</code> function from the <code>scdney</code> package.</p>
<p>To find out the marker genes in cluster 4, we type in <code>4</code> in the <code>findmarker</code> function. We then look at the top 10 genes ranked by p-value. We can then use <code>ggplot</code> to visualise the distribution of one of the genes across the dataset.</p>
<pre class="r"><code>marker_cluster4 = findMarker(mat = mat,
                             cluster = simlr_result_k6$y$cluster,
                             cluster_id = 4)</code></pre>
<pre class="r"><code>marker_cluster4[1:10, ]</code></pre>
<pre><code>##          gene       P_value
## 12739    Gys2 6.068095e-153
## 19151    Shbg 2.513240e-134
## 12924     Hgd 1.577501e-126
## 19364 Slc27a2 8.229521e-124
## 6096     Gcgr 7.663681e-122
## 16209     Otc 1.338106e-115
## 12842      Hc 1.016114e-113
## 15057  Mogat2 1.509759e-113
## 12729    Gulo 6.801648e-113
## 14081   Lect2 1.976735e-112</code></pre>
<pre class="r"><code>tsne_plotdf = data.frame(
  tsne1 = tsne_result$Y[, 1],
  tsne2 = tsne_result$Y[, 2]) %&gt;%
  dplyr::mutate(
    cluster = as.factor(simlr_result_k6$y$cluster),
    Gys2 = mat[&quot;Gys2&quot;, ])


ggplot(data = tsne_plotdf, aes(x = tsne1, y = tsne2, colour = Gys2) ) +
  geom_point(alpha = 0.5) +
  scale_color_viridis() +
  labs(col = &quot;Gys2 expression&quot;, x = &quot;tsne1&quot;, y = &quot;tsne2&quot;)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-14-1.png" width="768" /></p>
<h4>
<span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz
</h4>
<ol style="list-style-type: decimal">
<li><p>What does the above t-SNE plot tell you?</p></li>
<li><p>Here we repeat the analysis as above, but for cluster 3. See if you can understand the output.</p></li>
</ol>
<pre class="r"><code>marker_cluster3 = readRDS(paste0(datapath, &quot;marker_cluster3.rds&quot;))</code></pre>
<pre class="r"><code>tsne_plotdf = tsne_plotdf %&gt;%
  dplyr::mutate(Erich5 = mat[&quot;Erich5&quot;,])

ggplot(data = tsne_plotdf,
       mapping = aes(x = tsne1, y = tsne2, colour = Erich5)) +
  geom_point(alpha = 0.5) +
  scale_color_viridis() +
  labs(col=&quot;Erich5 expression&quot;)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-16-1.png" width="768" /></p>
</div>
<div id="q3" class="section level1">
<h1><span class="header-section-number">5</span> For a gene of interest, how can I visualise the gene expression distribution?</h1>
<p>We have already identified some interesting marker genes from our dataset. If we have a gene that we know, and we want to identify its expression pattern in our dataset, we can also visualise the distribution. For example, Hnf4a has been stated in literature as a marker gene for hepatoblast cell (citation to be added).</p>
<p>The figure on the left highlights cluster 4 and the figure on the right highlights the expression of Hnf4a.</p>
<p>This suggests that cluster 4 could belong to hepatoblast cell.</p>
<pre class="r"><code>tsne_plotdf = tsne_plotdf %&gt;%
  dplyr::mutate(Hnf4a = mat[&quot;Hnf4a&quot;,])


fig1 = ggplot(data = tsne_plotdf,
              mapping = aes(x = tsne1, y = tsne2)) +
  geom_point(aes(color = ifelse(cluster == 4, &#39;Yellow&#39;, &#39;Purple&#39;)), alpha = 0.5) +
  scale_colour_viridis_d() +
  labs(x = &quot;&quot;,
       y = &quot;&quot;,
       title = &quot;Cluster 4&quot;) +
  theme(legend.position = &quot;none&quot;)


fig2 = ggplot(data = tsne_plotdf,
              mapping = aes(x = tsne1, y = tsne2, colour = Hnf4a) ) +
  geom_point(alpha = 0.5) +
  scale_color_viridis() +
  labs(x = &quot;&quot;,
       y = &quot;&quot;,
       title = &quot;Hnf4a expression pattern&quot;)

ggarrange(fig1,fig2, ncol= 2, nrow = 1)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-17-1.png" width="1152" /></p>
<h4>
<span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz
</h4>
<p>See if you can understand the output of the following code.</p>
<pre class="r"><code>tsne_plotdf = tsne_plotdf %&gt;%
  dplyr::mutate(Epcam = mat[&quot;Epcam&quot;,])


fig1 = ggplot(data = tsne_plotdf, mapping = aes(x = tsne1, y = tsne2) ) +
  geom_point(aes(color = ifelse(cluster == 3, &#39;Yellow&#39;, &#39;Purple&#39;)), alpha = 0.5) +
  scale_colour_viridis_d() +
  labs(x = &quot;&quot;,
       y = &quot;&quot;,
       title = &quot;Cluster 3&quot;) +
  theme(legend.position = &quot;none&quot;)


fig2 = ggplot(data = tsne_plotdf,
               mapping = aes(x = tsne1, y = tsne2, colour = Epcam) ) +
  geom_point(alpha=0.5) +
  scale_color_viridis() +
  labs(x = &quot;&quot;,
       y = &quot;&quot;,
       title = &quot;Epcam expression pattern&quot;)

ggarrange(fig1,fig2, ncol= 2, nrow = 1)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-18-1.png" width="1152" /></p>
<p>As you may have already noticed from above steps, unsupervised clustering methods alone are not perfect in capturing cell type information. Using this step iteratively, we need to refine our cell type information.</p>
</div>
<div id="q4" class="section level1">
<h1><span class="header-section-number">6</span> What are the cell type composition in the data?</h1>
<p><strong>NOTE:</strong> From this step, we will assume we have correctly refined our cell type information from above steps and we will use the cell type information provided in Su et. al. 2017 and Yang et. al. 2017.</p>
<div id="cell-type-proportions" class="section level2">
<h2><span class="header-section-number">6.1</span> Cell type proportions</h2>
<pre class="r"><code>plot_data = data.frame(table(lab)) %&gt;%
  dplyr::mutate(lab = reorder(lab, Freq))

ggplot(plot_data,
       aes(x = lab,
           y = Freq,
           fill = lab)) +
  geom_bar(stat = &quot;identity&quot;) +
  labs(x = &quot;Cell types&quot;,
       y = &quot;Frequency&quot;,
       title = &quot;Composition of cell types&quot;) +
  coord_flip() +
  theme(legend.position = &quot;none&quot;)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-19-1.png" width="576" /></p>
<p>We observe that hepatoblast/hepatocyte is the largest population.</p>
</div>
</div>
<div id="extension-monocle" class="section level1">
<h1><span class="header-section-number">7</span> Extension: Monocle</h1>
<p>A popular question in scRNA-Seq analysis is if the gene expressions patterns changes over some time. The <code>monocle</code> method is a well-established psuedo-time trajectory reconstruction method from <a href="https://www.nature.com/articles/nbt.2859">Trapnell et. al. (2014)</a>.</p>
<p>The code below construct psuedo-time trajectory for the Hepatoblast/Hepatocyte cells in the merged data.</p>
<pre class="r"><code>## Subsetting data to &quot;hepatoblast/hepatocyte&quot;
monocle_data = subset_data[,colData(subset_data)$cellTypes %in% c(&quot;hepatoblast/hepatocyte&quot;)]
## Add a &quot;stage&quot; column to the colData of the monocle_data
colData(monocle_data)$stage = stringr::str_sub(colnames(monocle_data), 1, 3)
table(colData(monocle_data)$stage)
## monocle needs a rowData (data about each gene)
rowData(monocle_data) = DataFrame(gene_short_name = rownames(monocle_data))
monocle_data

## moncole requires a `CellDataSet` object to run.
## You can convert monocle_data into a `CellDataSet` object using the scran package.
monocle_CellDataSet = scran::convertTo(
  monocle_data,
  type = &quot;monocle&quot;,
  assay.type = &quot;scMerge&quot;
  # col.fields = c(&quot;cellTypes&quot;, &quot;stage&quot;, &quot;batch&quot;),
  # row.fields = c(&quot;gene_short_name&quot;)
  ) %&gt;%
  estimateSizeFactors()

## Performing differential gene test using &quot;stage&quot;.
diff_test_res = differentialGeneTest(
  monocle_CellDataSet, fullModelFormulaStr = &quot;~stage&quot;)

save(diff_test_res,
     monocle_CellDataSet,
     file = paste0(datapath, &quot;monocle_diff_test.RData&quot;))</code></pre>
<pre class="r"><code>load(paste0(datapath, &quot;monocle_diff_test.RData&quot;))
## We will select the top genes to be used for clustering and
## calculate dispersion (variability) parameters before constructing the trajectory
ordering_genes = row.names(subset(diff_test_res, qval &lt; 0.00001))
length(ordering_genes)</code></pre>
<pre><code>## [1] 868</code></pre>
<pre class="r"><code>monocle_CellDataSet = setOrderingFilter(monocle_CellDataSet, ordering_genes)
monocle_CellDataSet = estimateDispersions(monocle_CellDataSet) %&gt;% suppressWarnings()
# plot_ordering_genes(monocle_CellDataSet)

## Construcing the trajectory
monocle_CellDataSet = reduceDimension(monocle_CellDataSet,
                                      max_components = 2,
                                      method = &#39;DDRTree&#39;)
monocle_CellDataSet = orderCells(monocle_CellDataSet)
plot_cell_trajectory(monocle_CellDataSet, color_by = &quot;stage&quot;)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-21-1.png" width="768" /></p>
<pre class="r"><code># monocle::plot_cell_clusters(monocle_CellDataSet)
plot_genes_in_pseudotime(monocle_CellDataSet[c(&quot;Sarm1&quot;, &quot;Gm38388&quot;),], color_by = &quot;stage&quot;)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-21-2.png" width="768" /></p>
</div>
<div id="extension-can-we-use-the-data-as-reference-for-future-cell-type-classification" class="section level1">
<h1><span class="header-section-number">8</span> Extension: Can we use the data as reference for future cell type classification?</h1>
<p>A common application of single-cell RNA sequencing (RNA-seq) data is to identify discrete cell types. To take advantage of the large collection of well-annotated scRNA-seq datasets, scClassify package implements a set of methods to perform accurate cell type classification based on ensemble learning and sample size calculation.</p>
<p>The code below shows an example how to utilise a subset of data as reference data and then classify on the remaining data.</p>
<pre class="r"><code>exprsMat_liver &lt;- assay(subset_data, &quot;scMerge&quot;)

set.seed(2019)

# subsample 80% of the data as training dataset, and rest as test
idx &lt;- sample(ncol(exprsMat_liver), round(ncol(exprsMat_liver) * 0.8))

liver_exprsMat_train &lt;- exprsMat_liver[, idx]
liver_exprsMat_test &lt;- exprsMat_liver[, -idx]

liver_cellTypes_train &lt;- subset_data$cellTypes[idx]
liver_cellTypes_test &lt;- subset_data$cellTypes[-idx]


table(liver_cellTypes_train)</code></pre>
<pre><code>## liver_cellTypes_train
##          cholangiocyte       Endothelial Cell          Hematopoietic 
##                     83                     44                    117 
## hepatoblast/hepatocyte            Immune cell       Mesenchymal Cell 
##                    321                     44                     61</code></pre>
<p>We first perform non-ensemble scClassify by using 80% data as our reference dataset. We use <code>WKNN</code> as the KNN algorithm, <code>DE</code> (differential expression genes) as the gene selection method, and lastly pearson as the similarity calculation method.</p>
<pre class="r"><code>trainLiver &lt;- scClassify::train_scClassify(exprsMat_train = liver_exprsMat_train, 
                                           cellTypes_train = liver_cellTypes_train,
                                           algorithm = &quot;WKNN&quot;,
                                           selectFeatures = c(&quot;limma&quot;),
                                           similarity = c(&quot;pearson&quot;),
                                           returnList = FALSE,
                                           verbose = TRUE)</code></pre>
<pre><code>## after filtering not expressed genes 
## [1] 22864   670
## [1] &quot;Feature Selection...&quot;
## [1] &quot;Number of genes selected to construct HOPACH tree 300&quot;
## [1] &quot;Constructing tree ...&quot;
## [1] &quot;Training....&quot;
## [1] &quot;============ selecting features by: limma ============&quot;</code></pre>
<pre class="r"><code>trainLiver</code></pre>
<pre><code>## Class: scClassifyTrainModel 
## Model name: training 
## Feature selection methods: limma 
## Number of cells in the training data: 670 
## Number of cell types in the training data: 6</code></pre>
<p>We can visualise the cell type hirearchy tree using <code>plotCellTypeTree()</code>:</p>
<pre class="r"><code>scClassify::plotCellTypeTree(trainLiver@cellTypeTree)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-24-1.png" width="1152" /></p>
<p>Next, we perform <code>predict_scClassify()</code> with our trained model <code>trainRes = trainLiver</code> to predict the cell types of our query data matrix <code>liver_exprsMat_test</code>. Here, we used <code>pearson</code> as similarity metrics.</p>
<pre class="r"><code>pred_res &lt;- scClassify::predict_scClassify(exprsMat_test = liver_exprsMat_test, 
                               cellTypes_test = liver_cellTypes_test,
                               trainRes = trainLiver,
                               algorithm = &quot;WKNN&quot;,
                               features = c(&quot;limma&quot;),
                               similarity = c(&quot;pearson&quot;),
                               prob_threshold = 0.7,
                               verbose = TRUE)</code></pre>
<pre><code>## Ensemble learning is disabled... 
## Using parameters: 
## similarity  algorithm   features 
##  &quot;pearson&quot;     &quot;WKNN&quot;    &quot;limma&quot; 
## [1] &quot;Using dynamic correlation cutoff...&quot;
## [1] &quot;Using dynamic correlation cutoff...&quot;
## [1] &quot;Using dynamic correlation cutoff...&quot;
## classify_res
##                correct   correctly unassigned           intermediate 
##             0.91017964             0.00000000             0.02994012 
## incorrectly unassigned         error assigned          misclassified 
##             0.01197605             0.00000000             0.04790419</code></pre>
<pre class="r"><code>scClassify_res &lt;- pred_res$pearson_WKNN_limma$predRes</code></pre>
<p>Check prediction results with the original labels.</p>
<pre class="r"><code># create tsne object
set.seed(123)
tsne_result_test = Rtsne::Rtsne(t(liver_exprsMat_test), check_duplicates = FALSE)

#################################################

plot_data = data.frame(
  tsne1 = rep(tsne_result_test$Y[,1], 2),
  tsne2 = rep(tsne_result_test$Y[,2], 2),
  cluster = factor(c(liver_cellTypes_test, scClassify_res)),
  label = rep(c(&quot;Truth&quot;, &quot;scClassify&quot;), each = length(liver_cellTypes_test)))


ggplot(plot_data, aes(x = tsne1, y = tsne2, colour = cluster)) +
  geom_point(size = 2) +
  labs(title = &quot;t-SNE plot&quot;) +
  facet_grid(~label) +
  theme(legend.position = &quot;bottom&quot;)</code></pre>
<p><img src="downstream_files/figure-html/unnamed-chunk-26-1.png" width="1152" /></p>
<pre class="r"><code>tab &lt;- table(pred_res$pearson_WKNN_limma$predRes, liver_cellTypes_test)
knitr::kable(tab)</code></pre>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">cholangiocyte</th>
<th align="right">Endothelial Cell</th>
<th align="right">Hematopoietic</th>
<th align="right">hepatoblast/hepatocyte</th>
<th align="right">Immune cell</th>
<th align="right">Mesenchymal Cell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cholangiocyte</td>
<td align="right">17</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Endothelial Cell</td>
<td align="right">0</td>
<td align="right">8</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>Hematopoietic</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">27</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>hepatoblast/hepatocyte</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">73</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>hepatoblast/hepatocyte_cholangiocyte</td>
<td align="right">3</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td>Immune cell</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>Immune cell_Mesenchymal Cell_Hematopoietic</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Mesenchymal Cell</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">24</td>
</tr>
<tr class="odd">
<td>unassigned</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
</div>
<div id="sessioninfo" class="section level1">
<h1><span class="header-section-number">9</span> SessionInfo</h1>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 3.6.1 (2019-07-05)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS Mojave 10.14.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_AU.UTF-8/en_AU.UTF-8/en_AU.UTF-8/C/en_AU.UTF-8/en_AU.UTF-8
## 
## attached base packages:
##  [1] splines   parallel  stats4    stats     graphics  grDevices utils    
##  [8] datasets  methods   base     
## 
## other attached packages:
##  [1] scClassify_0.2.0            monocle_2.14.0             
##  [3] DDRTree_0.1.5               irlba_2.3.3                
##  [5] VGAM_1.1-1                  Matrix_1.2-17              
##  [7] plyr_1.8.4                  ggpubr_0.2.3               
##  [9] magrittr_1.5                viridis_0.5.1              
## [11] viridisLite_0.3.0           MAST_1.12.0                
## [13] ggplot2_3.2.1               cluster_2.1.0              
## [15] Rtsne_0.15                  mclust_5.4.5               
## [17] scdney_0.1.5                edgeR_3.28.0               
## [19] limma_3.42.0                dplyr_0.8.3                
## [21] SingleCellExperiment_1.8.0  SummarizedExperiment_1.16.0
## [23] DelayedArray_0.12.0         BiocParallel_1.20.0        
## [25] matrixStats_0.55.0          Biobase_2.46.0             
## [27] GenomicRanges_1.38.0        GenomeInfoDb_1.22.0        
## [29] IRanges_2.20.0              S4Vectors_0.24.0           
## [31] BiocGenerics_0.32.0        
## 
## loaded via a namespace (and not attached):
##   [1] snow_0.4-3             backports_1.1.5        Hmisc_4.2-0           
##   [4] igraph_1.2.4.1         lazyeval_0.2.2         proxyC_0.1.5          
##   [7] densityClust_0.3       fastICA_1.2-2          amap_0.8-17           
##  [10] digest_0.6.22          foreach_1.4.7          htmltools_0.4.0       
##  [13] checkmate_1.9.4        doParallel_1.0.15      mixtools_1.1.0        
##  [16] recipes_0.1.7          graphlayouts_0.5.0     gower_0.2.1           
##  [19] RcppParallel_4.4.4     docopt_0.6.1           colorspace_1.4-1      
##  [22] ggrepel_0.8.1          pan_1.6                xfun_0.10             
##  [25] sparsesvd_0.2          crayon_1.3.4           RCurl_1.95-4.12       
##  [28] lme4_1.1-21            zeallot_0.1.0          survival_2.44-1.1     
##  [31] iterators_1.0.12       glue_1.3.1             polyclip_1.10-0       
##  [34] gtable_0.3.0           ipred_0.9-9            zlibbioc_1.32.0       
##  [37] XVector_0.26.0         jomo_2.6-9             abind_1.4-5           
##  [40] scales_1.0.0           pheatmap_1.0.12        mvtnorm_1.0-11        
##  [43] Rcpp_1.0.2             htmlTable_1.13.2       proxy_0.4-23          
##  [46] foreign_0.8-72         Formula_1.2-3          lava_1.6.6            
##  [49] prodlim_2018.04.18     htmlwidgets_1.5.1      FNN_1.1.3             
##  [52] RColorBrewer_1.1-2     ellipsis_0.3.0         acepack_1.4.1         
##  [55] mice_3.6.0             pkgconfig_2.0.3        farver_1.1.0          
##  [58] nnet_7.3-12            locfit_1.5-9.1         caret_6.0-84          
##  [61] labeling_0.3           tidyselect_0.2.5       rlang_0.4.1           
##  [64] reshape2_1.4.3         pbmcapply_1.5.0        munsell_0.5.0         
##  [67] tools_3.6.1            generics_0.0.2         broom_0.5.2           
##  [70] ggridges_0.5.1         evaluate_0.14          stringr_1.4.0         
##  [73] yaml_2.2.0             ModelMetrics_1.2.2     knitr_1.25            
##  [76] tidygraph_1.1.2        RANN_2.6.1             randomForest_4.6-14   
##  [79] purrr_0.3.3            mitml_0.3-7            dendextend_1.12.0     
##  [82] ggraph_2.0.0           nlme_3.1-141           slam_0.1-45           
##  [85] compiler_3.6.1         rstudioapi_0.10        ggsignif_0.6.0        
##  [88] e1071_1.7-2            statmod_1.4.32         tibble_2.1.3          
##  [91] tweenr_1.0.1           DescTools_0.99.29      stringi_1.4.3         
##  [94] highr_0.8              lattice_0.20-38        hopach_2.46.0         
##  [97] nloptr_1.2.1           HSMMSingleCell_1.5.0   vctrs_0.2.0           
## [100] pillar_1.4.2           lifecycle_0.1.0        combinat_0.0-8        
## [103] cowplot_1.0.0          data.table_1.12.6      bitops_1.0-6          
## [106] R6_2.4.0               latticeExtra_0.6-28    gridExtra_2.3         
## [109] codetools_0.2-16       boot_1.3-23            MASS_7.3-51.4         
## [112] assertthat_0.2.1       minpack.lm_1.2-1       withr_2.1.2           
## [115] qlcMatrix_0.9.7        GenomeInfoDbData_1.2.2 diptest_0.75-7        
## [118] mgcv_1.8-29            expm_0.999-4           doSNOW_1.0.18         
## [121] grid_3.6.1             rpart_4.1-15           timeDate_3043.102     
## [124] tidyr_1.0.0            class_7.3-15           minqa_1.2.4           
## [127] rmarkdown_1.16         segmented_1.0-0        clusteval_0.1         
## [130] ggforce_0.3.1          lubridate_1.7.4        base64enc_0.1-3</code></pre>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
